#include <iostream>
#include <string>
#include <fstream>
#include <vector>

using namespace std;

//Структури
struct date
{
    int year, month, day, hour, minute, second;
    int dayInMonth(int month); //Функція для визначення кількості днів в місяці

    void getDate()     //Функція запиту дати від користувача та перевірка кожного значення на правилність введення
    {
        cout << "Enter year: ";
        cin >> this->year;
        do
        {
            cout << "Enter month: ";
            cin >> this->month;
        } while (this->month > 12 || this->month < 1);

        do
        {
            cout << "Enter day: ";
            cin >> this->day;
        } while (this->day > dayInMonth(this->month) || this->day < 1);

        do
        {
            cout << "Enter hour: ";
            cin >> this->hour;
        } while (this->hour > 24 || this->hour < 0);

        do
        {
            cout << "Enter minute: ";
            cin >> this->minute;
        } while (this->minute > 59 || this->hour < 0);

        do
        {
            cout << "Enter second: ";
            cin >> this->second;
        } while (this->hour > 59 || this->hour < 0);
    }
    
    void printDate()    //Функція зручного виводу дати та часу
    {
        cout << "Date: " << this->year << "." << this->month << "." << this->day << "\n";
        cout << "Time: " << this->hour << ":" << this->minute << ":" << this->second << "\n";
    }

    bool operator>(const date& other)
    {
        if (this->year > other.year) return true;
        else if (this->year < other.year) return false;

        if (this->month > other.month) return true;
        else if (this->month < other.month) return false;

        if (this->day > other.day) return true;
        else if (this->day < other.day) return false;

        if (this->hour > other.hour) return true;
        else if (this->hour < other.hour) return false;

        if (this->minute > other.minute) return true;
        else if (this->minute < other.minute) return false;

        return this->second > other.second;
    }
};

struct Product
{
    int id, shelf_life;
    string name, unit;
    double quantity;
    date production_date;

    void getInfo() //Функція для отримання данних про товар від користувача
    {
        cout << "Enter name: ";
        cin >> this->name;
        do
        {
            cout << "Enter type of unit(kg, liter, package, piece): ";
            cin >> this->unit;
        } while (this->unit != "kg" && this->unit != "liter" && this->unit != "package" && this->unit != "piece");

        cout << "Enter quantity: ";
        cin >> this->quantity;
        production_date.getDate();
        do
        {
            cout << "Enter shelf life(in days. Days must be less than 3660): ";
            cin >> this->shelf_life;
        } while (this->shelf_life < 0 || this->shelf_life > 3660);
    }
    
    void printInfo() //Функція для виведення данних про товар для користувача
    {
        cout << "=====================\n";
        cout << "Id: " << this->id << "\n";
        cout << "Product: " << this->name << "\n";
        cout << "Unit: " << this->unit << "\n";
        cout << "Quantity: " << this->quantity << "\n";
        production_date.printDate();
        cout << "Shelf time: " << this->shelf_life << "\n";
        cout << "=====================\n";
    }

};

//Функції винисені за структуру
int date::dayInMonth(int month)
{
    switch (month)
    {
    case 1: case 3: case 5: case 7: case 8: case 10: case 12:
        return 31;
    case 4: case 6: case 9: case 11:
        return 30;
    case 2:
        return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? 29 : 28;
    default:
        return -1;  // Повертаємо -1 у випадку некоректного місяця
    }
}

//Функції
//Функції для текстової бази данних
void txtDatabaseManagement();//Функція керування датабазою у вигляді файлу
void addElement(const string& filename, vector<Product>& database);
void recordDatabase(const vector<Product>& database, const string& filename);
void restore(const string& filename, vector<Product>& database);
void readAllDatabase(const string& filename);
void searchElements(const string& filename);
void modifyElement(const string& filename, vector<Product>& buffer);
void delElement(const string& filenamem, vector<Product>& buffer);

int main()
{
    cout << "--- Database loaded successfully! ---\n";
    int mode;
    cout << "Please, select a number of mode:\n1. Datebase management\n2. Demontstration mode \n3. Benchmark\nMode: ";
    cin >> mode;
    
    switch(mode)
    {
        case 1:
            cout << "\nPlease enter a number of mode:\n1. Vector Database \n2. TXT File Database\n3. Bin File Database\nMode: ";
            int modeManagement;
            cin >> modeManagement;
            switch(modeManagement)
            {
                case 2:
                    txtDatabaseManagement();
                    break;
                default:
                    cerr << "Error! You enter incoretct database\n";
            }
            break;
        default:
            cerr << "Error! You enter incoretct mode\n";
            break;
    }
}

void txtDatabaseManagement()
{
    const string filename = "database.txt";
    fstream outputFile(filename, ios::app);

    if (!outputFile.is_open())
    {
        cerr << "\n### Error opening the file " << filename << ". ###\n";
        return;
    }

    bool manage = true;
    vector<Product> bufer; //Масив для збереження тимчасових елементів

    while (manage)
    {
        cout << "\nHere you can manage the text database. Please select a operation: \n";
        cout << "0. Exit\n1. Add element to database\n2. Record date to file\n3. Restore database\n4. Output database\n5. Searh for an product by criteria\n6. Modify an element\n7. Delete database or element";
        cout << "Please enter a number of operation: ";
        int operation;
        cin >> operation;
        switch(operation)
        {
            case 0:
                manage = false;
                break;
            case 1:
                addElement(filename, bufer);
                break;
            case 2: 
                recordDatabase(bufer, filename);
                break;
            case 3:
                restore(filename, bufer);
                break;
            case 4:
                readAllDatabase(filename);
                break;
            case 5:
                searchElements(filename);
                break;
            case 6:
                modifyElement(filename, bufer);
                break;
            case 7:
                delElement(filename, bufer);
                break;
        }
    }
    
    cout << "\n=== Text database file '" << filename << "' has been created/updated. ===\n";
    outputFile.close();
}

void addElement(const string& filename, vector<Product>& database)
{
    restore(filename, database);
    Product newProduct;
    newProduct.id = database.size() + 1;
    newProduct.getInfo();
    database.push_back(newProduct);
    cout << "\n=== Product added to buffer successfully. ===\n";
}

void recordDatabase(const vector<Product>& database, const string& filename)
{
    ofstream clearFile(filename, ios::trunc);
    clearFile.close();
    ofstream outputFile(filename, ios::in);

    if (!outputFile.is_open())
    {
        cerr << "\n### Error opening the file " << filename << "###\n";
        return;
    }

    for (const Product& product : database)
    {
        outputFile << product.id << ' ' << product.name << ' ' << product.unit << ' ' << product.quantity << ' ';
        outputFile << product.production_date.year << ' ' << product.production_date.month << ' ' << product.production_date.day << ' ';
        outputFile << product.production_date.hour << ' ' << product.production_date.minute << ' ' << product.production_date.second << ' ';
        outputFile << product.shelf_life << '\n';
    }

    cout << "\n=== Database has been recorded to the file '" << filename << "'. ===\n";
    outputFile.close();
}

void readAllDatabase(const string& filename)
{
    ifstream readFile(filename);

    if (!readFile.is_open())
    {
        cerr << "\n### Error opening the file " << filename << "###\n";
        return;
    }
    cout << "\nAll product in database: \n";
    Product product;
    while (readFile >> product.id >> product.name >> product.unit >> product.quantity
        >> product.production_date.year >> product.production_date.month >> product.production_date.day
        >> product.production_date.hour >> product.production_date.minute >> product.production_date.second
        >> product.shelf_life)
    {
        product.printInfo();
    }

    cout << "\n=== Database has been read from the file " << filename << ". ===\n";
    readFile.close();
}

void restore(const string& filename, vector<Product>& database) 
{
    ifstream readFile(filename);

    if (!readFile.is_open()) {
        cerr << "\n### Error opening the file " << filename << ". ###\n";
        return;
    }

    Product product;
    while (readFile >> product.id >> product.name >> product.unit >> product.quantity
           >> product.production_date.year >> product.production_date.month >> product.production_date.day
           >> product.production_date.hour >> product.production_date.minute >> product.production_date.second
           >> product.shelf_life) 
    {

        database.push_back(product);
    }

    cout << "\n=== Database has been restored from the file " << filename << ". ===\n";
    readFile.close();
}

void searchElements(const string& filename) {
    vector<Product> allCoincidence;
    string fragment;
    int diaposoneStart, diaposoneEnd, criterion;
    date startDate;;
    bool name = false, numOfUnit = false, date = false;

    do {
        cout << "Select criterion:\n";
        cout << "1. Name\n2. Numbers of units\n3. Date\n";
        cout << "Please, enter a number criterion or `0` for exit: ";
        cin >> criterion;

        switch (criterion) {
        case 0:
            break;
        case 1:
            cout << "Enter a name of product: ";
            cin >> fragment;
            name = true;
            break;
        case 2:
            cout << "Enter a range units:\n";
            cout << "Enter the smallest value: ";
            cin >> diaposoneStart;
            cout << "Enter the greatest value: ";
            cin >> diaposoneEnd;
            numOfUnit = true;
            break;
        case 3:
            cout << "Enter start date (YYYY MM DD HH MM SS): ";
            startDate.getDate();
            date = true;
            break;
        default:
            cerr << "\n### You entered a wrong number ###\n";
            break;
        }
    } while (criterion != 0);

    if (!name && !numOfUnit && !date) {
        cout << "\n### You didn't select any criterion ###\n";
        return;
    }

    ifstream readFile(filename);

    if (!readFile.is_open()) {
        cerr << "\n### Error opening the file " << filename << ". ###\n";
        return;
    }

    Product product;
    while (readFile >> product.id >> product.name >> product.unit >> product.quantity
           >> product.production_date.year >> product.production_date.month >> product.production_date.day
           >> product.production_date.hour >> product.production_date.minute >> product.production_date.second
           >> product.shelf_life) 
    {
        if ((name && product.name.find(fragment) != 0) || 
            (numOfUnit && (product.quantity > diaposoneEnd || 
             product.quantity < diaposoneStart)) || (date && startDate > product.production_date))
            continue;  
        allCoincidence.push_back(product);
    }

    for (auto& p : allCoincidence)
    {
        p.printInfo();
    }
}

void modifyElement(const string& filename, vector<Product>& buffer)
{
    cout << "Enter id of the element which you want to modify: ";
    int idModify;
    cin >> idModify;

    ifstream readFile(filename, ios::out);
    if (!readFile.is_open())
    {
        cerr << "\n### Error opening the file " << filename << "###\n";
        return;
    }
    buffer.clear();
    Product product;
    while (readFile >> product.id >> product.name >> product.unit >> product.quantity
        >> product.production_date.year >> product.production_date.month >> product.production_date.day
        >> product.production_date.hour >> product.production_date.minute >> product.production_date.second
        >> product.shelf_life)
    {
        if (product.id == idModify)
        {
            cout << "\n=== Element founded! ===\n";

            int operation;
            bool changed = false;
            do
            {
                if (changed) cout << "\nDo you want to change anything else?n\n";
                else cout << "\nWhat do you want to change?\n";
                cout << "0. Nothing\n1. Name\n2. Unit\n3.Quantity\n4. Production date\n5. shelf life\nEnter opearion: ";
                cin >> operation;
                changed = true;

                switch (operation)
                {
                    case 0:
                        break;
                    case 1:
                        cout << "Enter new name: ";
                        cin >> product.name;
                        cout << "\n=== Name changed succesfully! ===\n";
                    case 2:
                        cout << "Enter new unit: ";
                        cin >> product.unit;
                        cout << "\n=== Unit changed succesfully! ===\n";
                        break;
                    case 3:
                        cout << "Enter new quantity: ";
                        cin >> product.quantity;
                        cout << "\n=== Quantity changed succesfully! ===\n";
                    case 4:
                        cout << "Enter new production date: ";
                        product.production_date.getDate();
                        cout << "\n=== Production date changed succesfully! ===\n";
                    case 5:
                        cout << "Enter new shelf life: ";
                        cin >> product.shelf_life;
                        cout << "\n=== Shelf life changed succesfully! ===\n";
                    default:
                        cout << "\n### You enter wrong number! ###\n";
                        break;
                }
            } while (operation != 0);

        }
        buffer.push_back(product);
    }
    readFile.close();
}

void delElement(const string& filename, vector<Product>& buffer)
{
    cout << "Select operation for delete:\n";
    cout << "0. Exit\n1. Delete element by id\n2. Delete all data in database\nEnter operation: ";
    int operation;
    cin >> operation;
    if (operation <= 0 || operation > 2) return;

    if (operation == 1)
    {
        cout << "Enter id file which you want to delete: ";
        int delId;
        cin >> delId;
        bool deleted;
        ifstream readFile(filename, ios::out);
        if (!readFile.is_open())
        {
            cerr << "\n### Error opening the file " << filename << "###\n";
            return;
        }
        buffer.clear();
        Product product;
        while (readFile >> product.id >> product.name >> product.unit >> product.quantity
            >> product.production_date.year >> product.production_date.month >> product.production_date.day
            >> product.production_date.hour >> product.production_date.minute >> product.production_date.second
            >> product.shelf_life)
        {
            if (product.id == delId)
            {
                deleted = true;
                continue;
            }
            buffer.push_back(product);
        }
        readFile.close();

        if (deleted) cout << "\n=== Element with id " << delId << " was deleted! ===\n";
        else  cout << "\n### Element with id " << delId << " wasn`t deleted! ###\n";

        return;
    }
    else 
    {
        buffer.clear();
        cout << "\n=== Data was deleted succesfully! ===\n";
    }
};
